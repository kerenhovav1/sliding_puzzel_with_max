public class State {
    private Board board;
    private final Board target_board;

    /**
     * Constructs a State object with the given board configuration.
     * @param board the board configuration for the state
     */
    public State(Board board) {
        this.board = board;
        target_board =  createTargetBoard();
    }

    /**
     * Returns the board configuration of the state.
     * @return the board configuration
     */
    public Board getBoard() {
        return board;
    }

    /**
     * Returns the target board configuration for the state.
     * @return the target board configuration
     */
    public Board getTargetBoard() {
        return target_board;
    }

    /**
     * Creates a target board configuration based on the current board configuration.
     * The target board configuration is generated by arranging the numbers from 1 to (totalchars-1)
     * in a grid format, with each row separated by '|' and the empty space represented by '_'.
     * @return the target board configuration as a new Board object
     */
    private Board createTargetBoard() {
        int totalchars = board.getNumR() * board.getNumC();
        String strResult = "";
        for(int i = 1; i <= totalchars-1; i++) {
            strResult += i + " ";
            if(i % board.getNumC() == 0)
                strResult += "|";
        }

        strResult += "_";
        return new Board(strResult);
    }

    /**
     * Checks if the current state is a goal state.
     * A state is considered a goal state if its board configuration is equal to the target board configuration.
     * @return true if the state is a goal state, false otherwise
     */
    public boolean isGoal() {
        return board.equals(getTargetBoard());
    }

    /**
     * Generates an array of possible actions that can be performed on the current board state.
     * the action will be on the "empty space" tile.
     * @return an array of possible actions
     */
    public Action[] actions(){
        int index = 0;
        int row = board.getLocation_of_empty_tile()[0];
        int col = board.getLocation_of_empty_tile()[1];
        Action [] actions = new Action[4]; //  there is 4 possible moves

        // up
        if (row < board.getNumR() - 1) {
            actions[index++] = new Action(board.getTile(row + 1 , col),Direction.UP,true);
        }
        // if not possible  - false
        else  {
            actions[index++] = new Action(board.getTile(row , col),Direction.UP,false);
        }

        // down - if row = 0 then we cannot move it up
        if (row > 0) {
            actions[index++] = new Action(board.getTile(row - 1  , col),Direction.DOWN,true);
        }
        // not possible == false
        else  {
            actions[index++] = new Action(board.getTile(row , col),Direction.DOWN,false);
        }

        // right we are not in the first col (0)
        if (col > 0 ) {
            actions[index++] = new Action(board.getTile(row , col - 1 ),Direction.RIGHT,true);
        }
        // not tp get null
        else  {
            actions[index++] = new Action(board.getTile(row , col ),Direction.RIGHT,false);
        }

        // left -- do get to col
        if (col < board.getNumC() - 1 ) {
            actions[index++] = new Action(board.getTile(row , col + 1 ),Direction.LEFT,true);
        }

        else  {
            actions[index++] = new Action(board.getTile(row , col),Direction.LEFT,false);
        }
        return actions;
    }

    /**
     * Generates a new state resulting from applying the specified action to the current state.
     * @param action the action to apply
     * @return the new state after applying the action
     */
    public State result(Action action){
        // action is not possiable
        int row = board.getLocation_of_empty_tile()[0];
        int col = board.getLocation_of_empty_tile()[1];

        if (!action.getIsPossible() || action.getTileToMove() == null || action.getTileToMove().getTileNum() == (int)board.getEmptySpace())
            return this; // return the current state

        // we moved the "tile to move" to the empty space - the tile i want to move will always move to
        // the location of empty til

        Board newBoard = new Board(board);
        newBoard.getBoard()[row][col].setTileNum(action.getTileToMove().getTileNum());

        if (action.getDirectionToMove() == Direction.UP){
            newBoard.getBoard()[row][col].setTileNum(action.getTileToMove().getTileNum());
            newBoard.getBoard()[row+1][col].setTileNum((int)board.getEmptySpace());
            newBoard.setLocation_of_empty_tile(row + 1, col);
        }

        else if (action.getDirectionToMove() == Direction.DOWN){
            newBoard.getBoard()[row][col].setTileNum(action.getTileToMove().getTileNum());
            newBoard.getBoard()[row-1][col].setTileNum((int)board.getEmptySpace());
            newBoard.setLocation_of_empty_tile(row - 1, col);
        }

        else if (action.getDirectionToMove() == Direction.RIGHT){
            newBoard.getBoard()[row][col].setTileNum(action.getTileToMove().getTileNum());
            newBoard.getBoard()[row][col - 1].setTileNum((int)board.getEmptySpace());
            newBoard.setLocation_of_empty_tile(row, col - 1);
        }

        else {
            newBoard.getBoard()[row][col].setTileNum(action.getTileToMove().getTileNum());
            newBoard.getBoard()[row][col+1].setTileNum((int)board.getEmptySpace());
            newBoard.setLocation_of_empty_tile(row, col + 1);
        }

        State newState = new State(newBoard);
        return newState;

    }

    @Override
    public int hashCode() {
        return board.hashCode();
    }

    @Override
    public boolean equals(Object other) {
        if (!(other instanceof State)) {
            return false;
        }
        State otherState = (State) other;
        return board.equals(otherState.board);
    }
}
